package de.concepts.io;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.*;
import java.util.LinkedList;
import java.util.Properties;
import java.util.Queue;
import java.util.logging.*;

public class WatchDog {
    static String logfilePath = "c:\\tmp\\watchdog.log"; // will be overwritten later
    static final String WATCHDOG_LOGGING_PROPERTIES = "watchdog.properties";
    static Logger logger = Logger.getAnonymousLogger();

    static Queue<String> queueWithFilenames = new LinkedList<>();
    static Handler fileHandler = null;
    public static void main(String[] args) {
        String currentDirectory;
        File file = new File(".");
        currentDirectory = file.getAbsolutePath();
        configureLogging(currentDirectory);
        configureWatchDog();
        Path path = Paths.get(args[0]);
        logger.info(String.format("Watchdog started monitoring directory %s", args[0]));
        logger.info(String.format("Logfile at %s", logfilePath));

        try (WatchService watchService = FileSystems.getDefault().newWatchService()) {
            WatchKey key = path.register(watchService,
                    StandardWatchEventKinds.ENTRY_CREATE,
                    StandardWatchEventKinds.ENTRY_MODIFY,
                    StandardWatchEventKinds.ENTRY_DELETE);
            startListening(watchService);
        } catch (Exception e) {
            e.printStackTrace();
        }

        logger.info("Watchdog stopped monitoring.");
    }

    /**
     * configures watchdog
     */
    private static void configureWatchDog() {
        Properties properties = new Properties();
        FileInputStream in = null;
        try {
            in = new FileInputStream(WATCHDOG_LOGGING_PROPERTIES);
            properties.load(in);
            in.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        logfilePath = properties.getProperty("watchdog.logfile.path");
    }

    private static void configureLogging(String currentDirectory) {
        System.out.println("Looking for watchdog.properties within current working directory : "+ currentDirectory);

        try {

            LogManager manager = LogManager.getLogManager();
            manager.readConfiguration(new FileInputStream(WATCHDOG_LOGGING_PROPERTIES));

            try {
                fileHandler = new FileHandler(logfilePath, true); //file


                SimpleFormatter simple = new SimpleFormatter();
                fileHandler.setFormatter(simple);
                logger.addHandler(fileHandler);//adding Handler for file
                logger.info("File logging enabled.");
            } catch (IOException e) {
                // TODO Auto-generated catch block
            }

        } catch (IOException e) {
            System.err.println(e.getMessage());
        }
    }

    /**
     * @param watchService watchService for file / directory events
     * @throws InterruptedException exception when interrupted
     */
    private static void startListening(WatchService watchService) throws InterruptedException {
        boolean poll = true;
        while (poll) {
            WatchKey queuedKey = watchService.take();
            /*
             * Prevent receiving two separate ENTRY_MODIFY events: file modified and timestamp updated.
             * Instead, receive one ENTRY_MODIFY event with two counts. Do this by sleeping
             * In two words, the events are generated by your operation system. You've got two events
             * which means your OS performs copy in non-atomic way. If you try to read the file somewhere
             * between ENTRY_CREATE and ENTRY_MODIFY, it'll be inconsistent. But again, it depends on your OS.
             * For instance on Windows 7 I'm getting ENTRY_CREATE one time and ENTRY_MODIFY two times
             * for large files. So you actually cannot be sure whether or not the file is successfully
             * copied, you have to come up with application/OS dependent metrics.
             */
            Thread.sleep(50);
            for (WatchEvent<?> watchEvent : queuedKey.pollEvents()) {
                switch (watchEvent.kind().name()) {
                    case "ENTRY_CREATE":
                        // log.fine("New file: " watchEvent.context());
                        break;
                    case "ENTRY_MODIFY":
                        // log.info("File modified:  " + watchEvent.context());
                        String modifiedFileName = watchEvent.context().toString();
                        queueWithFilenames.offer(modifiedFileName); // add to queue to handle this file later
                        FileImporter fileImporter = new FileImporter(modifiedFileName);
                        fileImporter.start(queueWithFilenames);
                        break;
                    case "ENTRY_DELETE":
                        // log.info("File deleted: " + watchEvent.context());
                        break;
                    default:
                        logger.info("Unknown event for file. ");
                        break;
                }
                /*
                System.out.printf("\nkind=%s, count=%d, context=%s Context type=%s%n ", watchEvent.kind(), //
                        // ENTRY_MODIFY
                        watchEvent.count(), // 1,2..
                        watchEvent.context(), // the filename
                        ((Path) watchEvent.context()).getClass()); // Context type=class sun.nio.fs.WindowsPath

                this is to empty queue:
                while ( !queue.isEmpty() ) {
                    System.out.println( queue.poll() );
                }
                */
                if (!queuedKey.reset()) {
                    break;
                }

            }
            poll = queuedKey.reset();
        }
    }
}