package de.concepts.io;

import java.nio.file.*;
import java.util.LinkedList;
import java.util.Queue;
import java.util.logging.Logger;

public class WatchDog {
    private static final Logger log = Logger.getLogger(WatchDog.class.getName());

    public static Queue<String> queue = new LinkedList<String>();

    public static void main(String[] args) {

        Path path = Paths.get(args[0]);
        log.info("Watchdog started monitoring directory " + args[0]);

        try (WatchService watchService = FileSystems.getDefault().newWatchService()) {
            WatchKey key = path.register(watchService, StandardWatchEventKinds.ENTRY_CREATE,
                    StandardWatchEventKinds.ENTRY_MODIFY, StandardWatchEventKinds.ENTRY_DELETE);
            startListening(watchService);
        } catch (Exception e) {
            e.printStackTrace();
        }

        System.out.println("done");
    }

    /**
     * In two words, the events are generated by your operation system. You've got two events
     * which means your OS performs copy in non-atomic way. If you try to read the file somewhere
     * between ENTRY_CREATE and ENTRY_MODIFY, it'll be inconsistent. But again, it depends on your OS.
     * For instance on Windows 7 I'm getting ENTRY_CREATE one time and ENTRY_MODIFY two times
     * for large files. So you actually cannot be sure whether or not the file is successfully
     * copied, you have to come up with application/OS dependent metrics.
     *
     * @param watchService
     * @throws InterruptedException
     */
    private static void startListening(WatchService watchService) throws InterruptedException {
        while (true) {
            WatchKey queuedKey = watchService.take();
            // Prevent receiving two separate ENTRY_MODIFY events: file modified
            // and timestamp updated. Instead, receive one ENTRY_MODIFY event
            // with two counts.
            Thread.sleep(50);
            for (WatchEvent<?> watchEvent : queuedKey.pollEvents()) {

                //do something useful with the modified file/folder here
                switch (watchEvent.kind().name()) {
                    case "ENTRY_CREATE":
                        // System.out.printf("New file: " + watchEvent.context());
                        // log.fine("ignoring create event");
                        break;
                    case "ENTRY_MODIFY":
                        // System.out.printf("File modified:  " + watchEvent.context());
                        // log.info("#");
                        queue.offer(watchEvent.context().toString()); // add to queue to handle later
                        FileImporter R1 = new FileImporter( "Thread-1");
                        R1.start(queue);

                        break;
                    case "ENTRY_DELETE":
                        // System.out.printf("File deleted: " + watchEvent.context());
                        // log.info("-");
                        break;
                    default:
                        log.info("Unknown event for file. ");
                        break;
                }
                /*
                System.out.printf("\nkind=%s, count=%d, context=%s Context type=%s%n ", watchEvent.kind(), //
                        // ENTRY_MODIFY
                        watchEvent.count(), // 1,2..
                        watchEvent.context(), // the filename
                        ((Path) watchEvent.context()).getClass()); // Context type=class sun.nio.fs.WindowsPath
                */

                /* this is to empty queue:
                while ( !queue.isEmpty() ) {
                    System.out.println( queue.poll() );
                }
                */
                if (!queuedKey.reset()) {
                    break;
                }

            }
        }
    }
}